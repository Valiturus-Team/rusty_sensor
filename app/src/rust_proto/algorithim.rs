// This file is generated by rust-protobuf 3.2.0. Do not edit
// .proto file is parsed by protoc --rust-out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `definitions/algorithim/algorithim.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_2_0;

///
/// End Algorthims
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:Timed)
pub struct Timed {
    // message fields
    // @@protoc_insertion_point(field:Timed.duration)
    pub duration: u32,
    // special fields
    // @@protoc_insertion_point(special_field:Timed.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Timed {
    fn default() -> &'a Timed {
        <Timed as ::protobuf::Message>::default_instance()
    }
}

impl Timed {
    pub fn new() -> Timed {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "duration",
            |m: &Timed| { &m.duration },
            |m: &mut Timed| { &mut m.duration },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Timed>(
            "Timed",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Timed {
    const NAME: &'static str = "Timed";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.duration = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.duration != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.duration);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.duration != 0 {
            os.write_uint32(1, self.duration)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Timed {
        Timed::new()
    }

    fn clear(&mut self) {
        self.duration = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Timed {
        static instance: Timed = Timed {
            duration: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Timed {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Timed").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Timed {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Timed {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:Counted)
pub struct Counted {
    // message fields
    // @@protoc_insertion_point(field:Counted.counts)
    pub counts: u32,
    // special fields
    // @@protoc_insertion_point(special_field:Counted.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Counted {
    fn default() -> &'a Counted {
        <Counted as ::protobuf::Message>::default_instance()
    }
}

impl Counted {
    pub fn new() -> Counted {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "counts",
            |m: &Counted| { &m.counts },
            |m: &mut Counted| { &mut m.counts },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Counted>(
            "Counted",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Counted {
    const NAME: &'static str = "Counted";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.counts = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.counts != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.counts);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.counts != 0 {
            os.write_uint32(1, self.counts)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Counted {
        Counted::new()
    }

    fn clear(&mut self) {
        self.counts = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Counted {
        static instance: Counted = Counted {
            counts: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Counted {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Counted").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Counted {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Counted {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///
/// Start Algorithims
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:SpikeStart)
pub struct SpikeStart {
    // special fields
    // @@protoc_insertion_point(special_field:SpikeStart.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SpikeStart {
    fn default() -> &'a SpikeStart {
        <SpikeStart as ::protobuf::Message>::default_instance()
    }
}

impl SpikeStart {
    pub fn new() -> SpikeStart {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SpikeStart>(
            "SpikeStart",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SpikeStart {
    const NAME: &'static str = "SpikeStart";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SpikeStart {
        SpikeStart::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SpikeStart {
        static instance: SpikeStart = SpikeStart {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SpikeStart {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SpikeStart").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SpikeStart {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SpikeStart {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///
/// Configurations
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:Bouncing)
pub struct Bouncing {
    // message fields
    // @@protoc_insertion_point(field:Bouncing.jumps)
    pub jumps: u32,
    // special fields
    // @@protoc_insertion_point(special_field:Bouncing.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Bouncing {
    fn default() -> &'a Bouncing {
        <Bouncing as ::protobuf::Message>::default_instance()
    }
}

impl Bouncing {
    pub fn new() -> Bouncing {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "jumps",
            |m: &Bouncing| { &m.jumps },
            |m: &mut Bouncing| { &mut m.jumps },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Bouncing>(
            "Bouncing",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Bouncing {
    const NAME: &'static str = "Bouncing";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.jumps = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.jumps != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.jumps);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.jumps != 0 {
            os.write_uint32(1, self.jumps)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Bouncing {
        Bouncing::new()
    }

    fn clear(&mut self) {
        self.jumps = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Bouncing {
        static instance: Bouncing = Bouncing {
            jumps: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Bouncing {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Bouncing").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Bouncing {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Bouncing {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///
/// Outputs
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:BouningRep)
pub struct BouningRep {
    // message fields
    // @@protoc_insertion_point(field:BouningRep.averageHeight)
    pub averageHeight: u32,
    // @@protoc_insertion_point(field:BouningRep.averageGroundContactTime)
    pub averageGroundContactTime: u32,
    // @@protoc_insertion_point(field:BouningRep.measurements)
    pub measurements: ::std::vec::Vec<BounceMeasurment>,
    // special fields
    // @@protoc_insertion_point(special_field:BouningRep.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BouningRep {
    fn default() -> &'a BouningRep {
        <BouningRep as ::protobuf::Message>::default_instance()
    }
}

impl BouningRep {
    pub fn new() -> BouningRep {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "averageHeight",
            |m: &BouningRep| { &m.averageHeight },
            |m: &mut BouningRep| { &mut m.averageHeight },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "averageGroundContactTime",
            |m: &BouningRep| { &m.averageGroundContactTime },
            |m: &mut BouningRep| { &mut m.averageGroundContactTime },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "measurements",
            |m: &BouningRep| { &m.measurements },
            |m: &mut BouningRep| { &mut m.measurements },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BouningRep>(
            "BouningRep",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BouningRep {
    const NAME: &'static str = "BouningRep";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.averageHeight = is.read_uint32()?;
                },
                16 => {
                    self.averageGroundContactTime = is.read_uint32()?;
                },
                26 => {
                    self.measurements.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.averageHeight != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.averageHeight);
        }
        if self.averageGroundContactTime != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.averageGroundContactTime);
        }
        for value in &self.measurements {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.averageHeight != 0 {
            os.write_uint32(1, self.averageHeight)?;
        }
        if self.averageGroundContactTime != 0 {
            os.write_uint32(2, self.averageGroundContactTime)?;
        }
        for v in &self.measurements {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BouningRep {
        BouningRep::new()
    }

    fn clear(&mut self) {
        self.averageHeight = 0;
        self.averageGroundContactTime = 0;
        self.measurements.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BouningRep {
        static instance: BouningRep = BouningRep {
            averageHeight: 0,
            averageGroundContactTime: 0,
            measurements: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BouningRep {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BouningRep").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BouningRep {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BouningRep {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:BounceMeasurment)
pub struct BounceMeasurment {
    // message fields
    // @@protoc_insertion_point(field:BounceMeasurment.groundContactTime)
    pub groundContactTime: u32,
    // @@protoc_insertion_point(field:BounceMeasurment.height)
    pub height: u32,
    // special fields
    // @@protoc_insertion_point(special_field:BounceMeasurment.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BounceMeasurment {
    fn default() -> &'a BounceMeasurment {
        <BounceMeasurment as ::protobuf::Message>::default_instance()
    }
}

impl BounceMeasurment {
    pub fn new() -> BounceMeasurment {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "groundContactTime",
            |m: &BounceMeasurment| { &m.groundContactTime },
            |m: &mut BounceMeasurment| { &mut m.groundContactTime },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "height",
            |m: &BounceMeasurment| { &m.height },
            |m: &mut BounceMeasurment| { &mut m.height },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BounceMeasurment>(
            "BounceMeasurment",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BounceMeasurment {
    const NAME: &'static str = "BounceMeasurment";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.groundContactTime = is.read_uint32()?;
                },
                16 => {
                    self.height = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.groundContactTime != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.groundContactTime);
        }
        if self.height != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.height);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.groundContactTime != 0 {
            os.write_uint32(1, self.groundContactTime)?;
        }
        if self.height != 0 {
            os.write_uint32(2, self.height)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BounceMeasurment {
        BounceMeasurment::new()
    }

    fn clear(&mut self) {
        self.groundContactTime = 0;
        self.height = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BounceMeasurment {
        static instance: BounceMeasurment = BounceMeasurment {
            groundContactTime: 0,
            height: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BounceMeasurment {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BounceMeasurment").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BounceMeasurment {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BounceMeasurment {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Algorithm algorithim configuration
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:AlgorithimConfiguration)
pub struct AlgorithimConfiguration {
    // message oneof groups
    pub endAlgorithim: ::std::option::Option<algorithim_configuration::EndAlgorithim>,
    pub startAlgorthim: ::std::option::Option<algorithim_configuration::StartAlgorthim>,
    pub configuration: ::std::option::Option<algorithim_configuration::Configuration>,
    // special fields
    // @@protoc_insertion_point(special_field:AlgorithimConfiguration.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AlgorithimConfiguration {
    fn default() -> &'a AlgorithimConfiguration {
        <AlgorithimConfiguration as ::protobuf::Message>::default_instance()
    }
}

impl AlgorithimConfiguration {
    pub fn new() -> AlgorithimConfiguration {
        ::std::default::Default::default()
    }

    // .Timed timed = 1;

    pub fn timed(&self) -> &Timed {
        match self.endAlgorithim {
            ::std::option::Option::Some(algorithim_configuration::EndAlgorithim::Timed(ref v)) => v,
            _ => <Timed as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_timed(&mut self) {
        self.endAlgorithim = ::std::option::Option::None;
    }

    pub fn has_timed(&self) -> bool {
        match self.endAlgorithim {
            ::std::option::Option::Some(algorithim_configuration::EndAlgorithim::Timed(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_timed(&mut self, v: Timed) {
        self.endAlgorithim = ::std::option::Option::Some(algorithim_configuration::EndAlgorithim::Timed(v))
    }

    // Mutable pointer to the field.
    pub fn mut_timed(&mut self) -> &mut Timed {
        if let ::std::option::Option::Some(algorithim_configuration::EndAlgorithim::Timed(_)) = self.endAlgorithim {
        } else {
            self.endAlgorithim = ::std::option::Option::Some(algorithim_configuration::EndAlgorithim::Timed(Timed::new()));
        }
        match self.endAlgorithim {
            ::std::option::Option::Some(algorithim_configuration::EndAlgorithim::Timed(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_timed(&mut self) -> Timed {
        if self.has_timed() {
            match self.endAlgorithim.take() {
                ::std::option::Option::Some(algorithim_configuration::EndAlgorithim::Timed(v)) => v,
                _ => panic!(),
            }
        } else {
            Timed::new()
        }
    }

    // .SpikeStart spikeStart = 2;

    pub fn spikeStart(&self) -> &SpikeStart {
        match self.startAlgorthim {
            ::std::option::Option::Some(algorithim_configuration::StartAlgorthim::SpikeStart(ref v)) => v,
            _ => <SpikeStart as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_spikeStart(&mut self) {
        self.startAlgorthim = ::std::option::Option::None;
    }

    pub fn has_spikeStart(&self) -> bool {
        match self.startAlgorthim {
            ::std::option::Option::Some(algorithim_configuration::StartAlgorthim::SpikeStart(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_spikeStart(&mut self, v: SpikeStart) {
        self.startAlgorthim = ::std::option::Option::Some(algorithim_configuration::StartAlgorthim::SpikeStart(v))
    }

    // Mutable pointer to the field.
    pub fn mut_spikeStart(&mut self) -> &mut SpikeStart {
        if let ::std::option::Option::Some(algorithim_configuration::StartAlgorthim::SpikeStart(_)) = self.startAlgorthim {
        } else {
            self.startAlgorthim = ::std::option::Option::Some(algorithim_configuration::StartAlgorthim::SpikeStart(SpikeStart::new()));
        }
        match self.startAlgorthim {
            ::std::option::Option::Some(algorithim_configuration::StartAlgorthim::SpikeStart(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_spikeStart(&mut self) -> SpikeStart {
        if self.has_spikeStart() {
            match self.startAlgorthim.take() {
                ::std::option::Option::Some(algorithim_configuration::StartAlgorthim::SpikeStart(v)) => v,
                _ => panic!(),
            }
        } else {
            SpikeStart::new()
        }
    }

    // .Bouncing bouncing = 3;

    pub fn bouncing(&self) -> &Bouncing {
        match self.configuration {
            ::std::option::Option::Some(algorithim_configuration::Configuration::Bouncing(ref v)) => v,
            _ => <Bouncing as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_bouncing(&mut self) {
        self.configuration = ::std::option::Option::None;
    }

    pub fn has_bouncing(&self) -> bool {
        match self.configuration {
            ::std::option::Option::Some(algorithim_configuration::Configuration::Bouncing(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_bouncing(&mut self, v: Bouncing) {
        self.configuration = ::std::option::Option::Some(algorithim_configuration::Configuration::Bouncing(v))
    }

    // Mutable pointer to the field.
    pub fn mut_bouncing(&mut self) -> &mut Bouncing {
        if let ::std::option::Option::Some(algorithim_configuration::Configuration::Bouncing(_)) = self.configuration {
        } else {
            self.configuration = ::std::option::Option::Some(algorithim_configuration::Configuration::Bouncing(Bouncing::new()));
        }
        match self.configuration {
            ::std::option::Option::Some(algorithim_configuration::Configuration::Bouncing(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_bouncing(&mut self) -> Bouncing {
        if self.has_bouncing() {
            match self.configuration.take() {
                ::std::option::Option::Some(algorithim_configuration::Configuration::Bouncing(v)) => v,
                _ => panic!(),
            }
        } else {
            Bouncing::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(3);
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, Timed>(
            "timed",
            AlgorithimConfiguration::has_timed,
            AlgorithimConfiguration::timed,
            AlgorithimConfiguration::mut_timed,
            AlgorithimConfiguration::set_timed,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, SpikeStart>(
            "spikeStart",
            AlgorithimConfiguration::has_spikeStart,
            AlgorithimConfiguration::spikeStart,
            AlgorithimConfiguration::mut_spikeStart,
            AlgorithimConfiguration::set_spikeStart,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, Bouncing>(
            "bouncing",
            AlgorithimConfiguration::has_bouncing,
            AlgorithimConfiguration::bouncing,
            AlgorithimConfiguration::mut_bouncing,
            AlgorithimConfiguration::set_bouncing,
        ));
        oneofs.push(algorithim_configuration::EndAlgorithim::generated_oneof_descriptor_data());
        oneofs.push(algorithim_configuration::StartAlgorthim::generated_oneof_descriptor_data());
        oneofs.push(algorithim_configuration::Configuration::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AlgorithimConfiguration>(
            "AlgorithimConfiguration",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AlgorithimConfiguration {
    const NAME: &'static str = "AlgorithimConfiguration";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.endAlgorithim = ::std::option::Option::Some(algorithim_configuration::EndAlgorithim::Timed(is.read_message()?));
                },
                18 => {
                    self.startAlgorthim = ::std::option::Option::Some(algorithim_configuration::StartAlgorthim::SpikeStart(is.read_message()?));
                },
                26 => {
                    self.configuration = ::std::option::Option::Some(algorithim_configuration::Configuration::Bouncing(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.endAlgorithim {
            match v {
                &algorithim_configuration::EndAlgorithim::Timed(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.startAlgorthim {
            match v {
                &algorithim_configuration::StartAlgorthim::SpikeStart(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.configuration {
            match v {
                &algorithim_configuration::Configuration::Bouncing(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let ::std::option::Option::Some(ref v) = self.endAlgorithim {
            match v {
                &algorithim_configuration::EndAlgorithim::Timed(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.startAlgorthim {
            match v {
                &algorithim_configuration::StartAlgorthim::SpikeStart(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.configuration {
            match v {
                &algorithim_configuration::Configuration::Bouncing(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AlgorithimConfiguration {
        AlgorithimConfiguration::new()
    }

    fn clear(&mut self) {
        self.endAlgorithim = ::std::option::Option::None;
        self.startAlgorthim = ::std::option::Option::None;
        self.configuration = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AlgorithimConfiguration {
        static instance: AlgorithimConfiguration = AlgorithimConfiguration {
            endAlgorithim: ::std::option::Option::None,
            startAlgorthim: ::std::option::Option::None,
            configuration: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AlgorithimConfiguration {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AlgorithimConfiguration").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AlgorithimConfiguration {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AlgorithimConfiguration {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `AlgorithimConfiguration`
pub mod algorithim_configuration {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:AlgorithimConfiguration.endAlgorithim)
    pub enum EndAlgorithim {
        // @@protoc_insertion_point(oneof_field:AlgorithimConfiguration.timed)
        Timed(super::Timed),
    }

    impl ::protobuf::Oneof for EndAlgorithim {
    }

    impl ::protobuf::OneofFull for EndAlgorithim {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::AlgorithimConfiguration as ::protobuf::MessageFull>::descriptor().oneof_by_name("endAlgorithim").unwrap()).clone()
        }
    }

    impl EndAlgorithim {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<EndAlgorithim>("endAlgorithim")
        }
    }

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:AlgorithimConfiguration.startAlgorthim)
    pub enum StartAlgorthim {
        // @@protoc_insertion_point(oneof_field:AlgorithimConfiguration.spikeStart)
        SpikeStart(super::SpikeStart),
    }

    impl ::protobuf::Oneof for StartAlgorthim {
    }

    impl ::protobuf::OneofFull for StartAlgorthim {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::AlgorithimConfiguration as ::protobuf::MessageFull>::descriptor().oneof_by_name("startAlgorthim").unwrap()).clone()
        }
    }

    impl StartAlgorthim {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<StartAlgorthim>("startAlgorthim")
        }
    }

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:AlgorithimConfiguration.configuration)
    pub enum Configuration {
        // @@protoc_insertion_point(oneof_field:AlgorithimConfiguration.bouncing)
        Bouncing(super::Bouncing),
    }

    impl ::protobuf::Oneof for Configuration {
    }

    impl ::protobuf::OneofFull for Configuration {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::AlgorithimConfiguration as ::protobuf::MessageFull>::descriptor().oneof_by_name("configuration").unwrap()).clone()
        }
    }

    impl Configuration {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Configuration>("configuration")
        }
    }
}

///  Measuremnts
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:Rep)
pub struct Rep {
    // message oneof groups
    pub rep: ::std::option::Option<rep::Rep>,
    // special fields
    // @@protoc_insertion_point(special_field:Rep.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Rep {
    fn default() -> &'a Rep {
        <Rep as ::protobuf::Message>::default_instance()
    }
}

impl Rep {
    pub fn new() -> Rep {
        ::std::default::Default::default()
    }

    // .BouningRep bouningRep = 1;

    pub fn bouningRep(&self) -> &BouningRep {
        match self.rep {
            ::std::option::Option::Some(rep::Rep::BouningRep(ref v)) => v,
            _ => <BouningRep as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_bouningRep(&mut self) {
        self.rep = ::std::option::Option::None;
    }

    pub fn has_bouningRep(&self) -> bool {
        match self.rep {
            ::std::option::Option::Some(rep::Rep::BouningRep(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_bouningRep(&mut self, v: BouningRep) {
        self.rep = ::std::option::Option::Some(rep::Rep::BouningRep(v))
    }

    // Mutable pointer to the field.
    pub fn mut_bouningRep(&mut self) -> &mut BouningRep {
        if let ::std::option::Option::Some(rep::Rep::BouningRep(_)) = self.rep {
        } else {
            self.rep = ::std::option::Option::Some(rep::Rep::BouningRep(BouningRep::new()));
        }
        match self.rep {
            ::std::option::Option::Some(rep::Rep::BouningRep(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_bouningRep(&mut self) -> BouningRep {
        if self.has_bouningRep() {
            match self.rep.take() {
                ::std::option::Option::Some(rep::Rep::BouningRep(v)) => v,
                _ => panic!(),
            }
        } else {
            BouningRep::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, BouningRep>(
            "bouningRep",
            Rep::has_bouningRep,
            Rep::bouningRep,
            Rep::mut_bouningRep,
            Rep::set_bouningRep,
        ));
        oneofs.push(rep::Rep::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Rep>(
            "Rep",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Rep {
    const NAME: &'static str = "Rep";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.rep = ::std::option::Option::Some(rep::Rep::BouningRep(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.rep {
            match v {
                &rep::Rep::BouningRep(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let ::std::option::Option::Some(ref v) = self.rep {
            match v {
                &rep::Rep::BouningRep(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Rep {
        Rep::new()
    }

    fn clear(&mut self) {
        self.rep = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Rep {
        static instance: Rep = Rep {
            rep: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Rep {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Rep").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Rep {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Rep {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `Rep`
pub mod rep {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:Rep.rep)
    pub enum Rep {
        // @@protoc_insertion_point(oneof_field:Rep.bouningRep)
        BouningRep(super::BouningRep),
    }

    impl ::protobuf::Oneof for Rep {
    }

    impl ::protobuf::OneofFull for Rep {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::Rep as ::protobuf::MessageFull>::descriptor().oneof_by_name("rep").unwrap()).clone()
        }
    }

    impl Rep {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Rep>("rep")
        }
    }
}

///
/// transfer Container
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:Message)
pub struct Message {
    // message oneof groups
    pub content: ::std::option::Option<message::Content>,
    // special fields
    // @@protoc_insertion_point(special_field:Message.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Message {
    fn default() -> &'a Message {
        <Message as ::protobuf::Message>::default_instance()
    }
}

impl Message {
    pub fn new() -> Message {
        ::std::default::Default::default()
    }

    // .AlgorithimConfiguration Algorithim = 1;

    pub fn Algorithim(&self) -> &AlgorithimConfiguration {
        match self.content {
            ::std::option::Option::Some(message::Content::Algorithim(ref v)) => v,
            _ => <AlgorithimConfiguration as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_Algorithim(&mut self) {
        self.content = ::std::option::Option::None;
    }

    pub fn has_Algorithim(&self) -> bool {
        match self.content {
            ::std::option::Option::Some(message::Content::Algorithim(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_Algorithim(&mut self, v: AlgorithimConfiguration) {
        self.content = ::std::option::Option::Some(message::Content::Algorithim(v))
    }

    // Mutable pointer to the field.
    pub fn mut_Algorithim(&mut self) -> &mut AlgorithimConfiguration {
        if let ::std::option::Option::Some(message::Content::Algorithim(_)) = self.content {
        } else {
            self.content = ::std::option::Option::Some(message::Content::Algorithim(AlgorithimConfiguration::new()));
        }
        match self.content {
            ::std::option::Option::Some(message::Content::Algorithim(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_Algorithim(&mut self) -> AlgorithimConfiguration {
        if self.has_Algorithim() {
            match self.content.take() {
                ::std::option::Option::Some(message::Content::Algorithim(v)) => v,
                _ => panic!(),
            }
        } else {
            AlgorithimConfiguration::new()
        }
    }

    // .Rep rep = 2;

    pub fn rep(&self) -> &Rep {
        match self.content {
            ::std::option::Option::Some(message::Content::Rep(ref v)) => v,
            _ => <Rep as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_rep(&mut self) {
        self.content = ::std::option::Option::None;
    }

    pub fn has_rep(&self) -> bool {
        match self.content {
            ::std::option::Option::Some(message::Content::Rep(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_rep(&mut self, v: Rep) {
        self.content = ::std::option::Option::Some(message::Content::Rep(v))
    }

    // Mutable pointer to the field.
    pub fn mut_rep(&mut self) -> &mut Rep {
        if let ::std::option::Option::Some(message::Content::Rep(_)) = self.content {
        } else {
            self.content = ::std::option::Option::Some(message::Content::Rep(Rep::new()));
        }
        match self.content {
            ::std::option::Option::Some(message::Content::Rep(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_rep(&mut self) -> Rep {
        if self.has_rep() {
            match self.content.take() {
                ::std::option::Option::Some(message::Content::Rep(v)) => v,
                _ => panic!(),
            }
        } else {
            Rep::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, AlgorithimConfiguration>(
            "Algorithim",
            Message::has_Algorithim,
            Message::Algorithim,
            Message::mut_Algorithim,
            Message::set_Algorithim,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, Rep>(
            "rep",
            Message::has_rep,
            Message::rep,
            Message::mut_rep,
            Message::set_rep,
        ));
        oneofs.push(message::Content::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Message>(
            "Message",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Message {
    const NAME: &'static str = "Message";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.content = ::std::option::Option::Some(message::Content::Algorithim(is.read_message()?));
                },
                18 => {
                    self.content = ::std::option::Option::Some(message::Content::Rep(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.content {
            match v {
                &message::Content::Algorithim(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &message::Content::Rep(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let ::std::option::Option::Some(ref v) = self.content {
            match v {
                &message::Content::Algorithim(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                },
                &message::Content::Rep(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Message {
        Message::new()
    }

    fn clear(&mut self) {
        self.content = ::std::option::Option::None;
        self.content = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Message {
        static instance: Message = Message {
            content: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Message {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Message").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Message {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Message {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `Message`
pub mod message {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:Message.content)
    pub enum Content {
        // @@protoc_insertion_point(oneof_field:Message.Algorithim)
        Algorithim(super::AlgorithimConfiguration),
        // @@protoc_insertion_point(oneof_field:Message.rep)
        Rep(super::Rep),
    }

    impl ::protobuf::Oneof for Content {
    }

    impl ::protobuf::OneofFull for Content {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::Message as ::protobuf::MessageFull>::descriptor().oneof_by_name("content").unwrap()).clone()
        }
    }

    impl Content {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Content>("content")
        }
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n'definitions/algorithim/algorithim.proto\"#\n\x05Timed\x12\x1a\n\x08du\
    ration\x18\x01\x20\x01(\rR\x08duration\"!\n\x07Counted\x12\x16\n\x06coun\
    ts\x18\x01\x20\x01(\rR\x06counts\"\x0c\n\nSpikeStart\"\x20\n\x08Bouncing\
    \x12\x14\n\x05jumps\x18\x01\x20\x01(\rR\x05jumps\"\xa5\x01\n\nBouningRep\
    \x12$\n\raverageHeight\x18\x01\x20\x01(\rR\raverageHeight\x12:\n\x18aver\
    ageGroundContactTime\x18\x02\x20\x01(\rR\x18averageGroundContactTime\x12\
    5\n\x0cmeasurements\x18\x03\x20\x03(\x0b2\x11.BounceMeasurmentR\x0cmeasu\
    rements\"X\n\x10BounceMeasurment\x12,\n\x11groundContactTime\x18\x01\x20\
    \x01(\rR\x11groundContactTime\x12\x16\n\x06height\x18\x02\x20\x01(\rR\
    \x06height\"\xc5\x01\n\x17AlgorithimConfiguration\x12\x1e\n\x05timed\x18\
    \x01\x20\x01(\x0b2\x06.TimedH\0R\x05timed\x12-\n\nspikeStart\x18\x02\x20\
    \x01(\x0b2\x0b.SpikeStartH\x01R\nspikeStart\x12'\n\x08bouncing\x18\x03\
    \x20\x01(\x0b2\t.BouncingH\x02R\x08bouncingB\x0f\n\rendAlgorithimB\x10\n\
    \x0estartAlgorthimB\x0f\n\rconfiguration\";\n\x03Rep\x12-\n\nbouningRep\
    \x18\x01\x20\x01(\x0b2\x0b.BouningRepH\0R\nbouningRepB\x05\n\x03rep\"j\n\
    \x07Message\x12:\n\nAlgorithim\x18\x01\x20\x01(\x0b2\x18.AlgorithimConfi\
    gurationH\0R\nAlgorithim\x12\x18\n\x03rep\x18\x02\x20\x01(\x0b2\x04.RepH\
    \0R\x03repB\t\n\x07contentJ\xca\n\n\x06\x12\x04\0\0;\x01\n\x08\n\x01\x0c\
    \x12\x03\0\0\x12\n\x1b\n\x02\x04\0\x12\x03\x05\0&\x1a\x10\nEnd\x20Algort\
    hims\n\n\n\n\x03\x04\0\x01\x12\x03\x05\x08\r\n\x0b\n\x04\x04\0\x02\0\x12\
    \x03\x05\x10$\n\x0c\n\x05\x04\0\x02\0\x05\x12\x03\x05\x10\x16\n\x0c\n\
    \x05\x04\0\x02\0\x01\x12\x03\x05\x17\x1f\n\x0c\n\x05\x04\0\x02\0\x03\x12\
    \x03\x05\"#\n\t\n\x02\x04\x01\x12\x03\x07\0&\n\n\n\x03\x04\x01\x01\x12\
    \x03\x07\x08\x0f\n\x0b\n\x04\x04\x01\x02\0\x12\x03\x07\x12$\n\x0c\n\x05\
    \x04\x01\x02\0\x05\x12\x03\x07\x12\x18\n\x0c\n\x05\x04\x01\x02\0\x01\x12\
    \x03\x07\x19\x1f\n\x0c\n\x05\x04\x01\x02\0\x03\x12\x03\x07\"#\n\x1e\n\
    \x02\x04\x02\x12\x03\x0c\0\x15\x1a\x13\nStart\x20Algorithims\n\n\n\n\x03\
    \x04\x02\x01\x12\x03\x0c\x08\x12\n\x1c\n\x02\x04\x03\x12\x04\x11\0\x13\
    \x01\x1a\x10\nConfigurations\n\n\n\n\x03\x04\x03\x01\x12\x03\x11\x08\x10\
    \n-\n\x04\x04\x03\x02\0\x12\x03\x12\x02\x13\"\x20\x20number\x20of\x20jum\
    ps\x20to\x20be\x20measured\n\n\x0c\n\x05\x04\x03\x02\0\x05\x12\x03\x12\
    \x02\x08\n\x0c\n\x05\x04\x03\x02\0\x01\x12\x03\x12\t\x0e\n\x0c\n\x05\x04\
    \x03\x02\0\x03\x12\x03\x12\x11\x12\n\x15\n\x02\x04\x04\x12\x04\x18\0\x1c\
    \x01\x1a\t\nOutputs\n\n\n\n\x03\x04\x04\x01\x12\x03\x18\x08\x12\n\x0b\n\
    \x04\x04\x04\x02\0\x12\x03\x19\x02\x1b\n\x0c\n\x05\x04\x04\x02\0\x05\x12\
    \x03\x19\x02\x08\n\x0c\n\x05\x04\x04\x02\0\x01\x12\x03\x19\t\x16\n\x0c\n\
    \x05\x04\x04\x02\0\x03\x12\x03\x19\x19\x1a\n\x0b\n\x04\x04\x04\x02\x01\
    \x12\x03\x1a\x02&\n\x0c\n\x05\x04\x04\x02\x01\x05\x12\x03\x1a\x02\x08\n\
    \x0c\n\x05\x04\x04\x02\x01\x01\x12\x03\x1a\t!\n\x0c\n\x05\x04\x04\x02\
    \x01\x03\x12\x03\x1a$%\n\x0b\n\x04\x04\x04\x02\x02\x12\x03\x1b\x02-\n\
    \x0c\n\x05\x04\x04\x02\x02\x04\x12\x03\x1b\x02\n\n\x0c\n\x05\x04\x04\x02\
    \x02\x06\x12\x03\x1b\x0b\x1b\n\x0c\n\x05\x04\x04\x02\x02\x01\x12\x03\x1b\
    \x1c(\n\x0c\n\x05\x04\x04\x02\x02\x03\x12\x03\x1b+,\n\n\n\x02\x04\x05\
    \x12\x04\x1e\0!\x01\n\n\n\x03\x04\x05\x01\x12\x03\x1e\x08\x18\n\x0b\n\
    \x04\x04\x05\x02\0\x12\x03\x1f\x02\x1f\n\x0c\n\x05\x04\x05\x02\0\x05\x12\
    \x03\x1f\x02\x08\n\x0c\n\x05\x04\x05\x02\0\x01\x12\x03\x1f\t\x1a\n\x0c\n\
    \x05\x04\x05\x02\0\x03\x12\x03\x1f\x1d\x1e\n\x0b\n\x04\x04\x05\x02\x01\
    \x12\x03\x20\x02\x14\n\x0c\n\x05\x04\x05\x02\x01\x05\x12\x03\x20\x02\x08\
    \n\x0c\n\x05\x04\x05\x02\x01\x01\x12\x03\x20\t\x0f\n\x0c\n\x05\x04\x05\
    \x02\x01\x03\x12\x03\x20\x12\x13\nJ\n\x02\x04\x06\x12\x04(\0,\x01\x1a$\
    \x20Algorithm\x20algorithim\x20configuration\n2\x18\nData\x20transfer\
    \x20messages\n\n\n\n\x03\x04\x06\x01\x12\x03(\x08\x1f\n\x0b\n\x04\x04\
    \x06\x08\0\x12\x03)\x02*\n\x0c\n\x05\x04\x06\x08\0\x01\x12\x03)\x08\x15\
    \n\x0b\n\x04\x04\x06\x02\0\x12\x03)\x18(\n\x0c\n\x05\x04\x06\x02\0\x06\
    \x12\x03)\x18\x1d\n\x0c\n\x05\x04\x06\x02\0\x01\x12\x03)\x1e#\n\x0c\n\
    \x05\x04\x06\x02\0\x03\x12\x03)&'\n\x0b\n\x04\x04\x06\x08\x01\x12\x03*\
    \x025\n\x0c\n\x05\x04\x06\x08\x01\x01\x12\x03*\x08\x16\n\x0b\n\x04\x04\
    \x06\x02\x01\x12\x03*\x193\n\x0c\n\x05\x04\x06\x02\x01\x06\x12\x03*\x19#\
    \n\x0c\n\x05\x04\x06\x02\x01\x01\x12\x03*$.\n\x0c\n\x05\x04\x06\x02\x01\
    \x03\x12\x03*12\n\x0b\n\x04\x04\x06\x08\x02\x12\x03+\x020\n\x0c\n\x05\
    \x04\x06\x08\x02\x01\x12\x03+\x08\x15\n\x0b\n\x04\x04\x06\x02\x02\x12\
    \x03+\x18.\n\x0c\n\x05\x04\x06\x02\x02\x06\x12\x03+\x18\x20\n\x0c\n\x05\
    \x04\x06\x02\x02\x01\x12\x03+!)\n\x0c\n\x05\x04\x06\x02\x02\x03\x12\x03+\
    ,-\n\x19\n\x02\x04\x07\x12\x04/\01\x01\x1a\r\x20Measuremnts\n\n\n\n\x03\
    \x04\x07\x01\x12\x03/\x08\x0b\n\x0b\n\x04\x04\x07\x08\0\x12\x030\x02*\n\
    \x0c\n\x05\x04\x07\x08\0\x01\x12\x030\x08\x0b\n\x0b\n\x04\x04\x07\x02\0\
    \x12\x030\x0e(\n\x0c\n\x05\x04\x07\x02\0\x06\x12\x030\x0e\x18\n\x0c\n\
    \x05\x04\x07\x02\0\x01\x12\x030\x19#\n\x0c\n\x05\x04\x07\x02\0\x03\x12\
    \x030&'\n\x20\n\x02\x04\x08\x12\x046\0;\x01\x1a\x14\ntransfer\x20Contain\
    er\n\n\n\n\x03\x04\x08\x01\x12\x036\x08\x0f\n\x0c\n\x04\x04\x08\x08\0\
    \x12\x047\x02:\x03\n\x0c\n\x05\x04\x08\x08\0\x01\x12\x037\x08\x0f\n\x0b\
    \n\x04\x04\x08\x02\0\x12\x038\x04+\n\x0c\n\x05\x04\x08\x02\0\x06\x12\x03\
    8\x04\x1b\n\x0c\n\x05\x04\x08\x02\0\x01\x12\x038\x1c&\n\x0c\n\x05\x04\
    \x08\x02\0\x03\x12\x038)*\n\x0b\n\x04\x04\x08\x02\x01\x12\x039\x04\x10\n\
    \x0c\n\x05\x04\x08\x02\x01\x06\x12\x039\x04\x07\n\x0c\n\x05\x04\x08\x02\
    \x01\x01\x12\x039\x08\x0b\n\x0c\n\x05\x04\x08\x02\x01\x03\x12\x039\x0e\
    \x0fb\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(0);
            let mut messages = ::std::vec::Vec::with_capacity(9);
            messages.push(Timed::generated_message_descriptor_data());
            messages.push(Counted::generated_message_descriptor_data());
            messages.push(SpikeStart::generated_message_descriptor_data());
            messages.push(Bouncing::generated_message_descriptor_data());
            messages.push(BouningRep::generated_message_descriptor_data());
            messages.push(BounceMeasurment::generated_message_descriptor_data());
            messages.push(AlgorithimConfiguration::generated_message_descriptor_data());
            messages.push(Rep::generated_message_descriptor_data());
            messages.push(Message::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
